==表结构设计优化==
1. **合理拆分大表（垂直拆分与水平拆分）**
垂直拆分：将大表中不常一起查询的列拆分到新表，减少单表宽度，提升查询时的数据加载效率。
水平拆分：按数据特征将大表数据分散到多个表或数据库。
2. **选择合适的数据类型**
用最小合适的数据类型：如存储年龄用 TINYINT（1 字节）而非 INT（4 字节）；存储短字符串用 VARCHAR 而非 TEXT。
避免不必要的大类型：如用 DATETIME（8 字节）存日期时间，而非 VARCHAR（存储和比较效率低）。
3. **增加冗余字段（反范式化）**
在查询频繁且关联复杂的场景，适当冗余字段减少表连接。
4. **分区表**
对大表按规则分成多个分区，查询时仅扫描相关分区，提升效率。
例如，按 create_time 范围分区日志表，查询指定时间范围数据时，只需访问对应分区。

==SQL 查询优化==
1. **索引优化**
创建合适索引：为查询条件（WHERE、JOIN、ORDER BY 字段）创建索引。
联合索引：对多条件查询，创建联合索引覆盖多个字段，如 CREATE INDEX idx_order_time_status ON orders(create_time, status)。
避免索引失效：不在索引字段上做函数操作。避免索引字段隐式类型转换（如字段是 VARCHAR，查询用 WHERE col = 123 改为 WHERE col = '123'）。
2. **优化查询语句**
避免 SELECT *：明确指定需要的列，减少数据传输量和 IO 开销。
分页查询优化：用 LIMIT 结合索引条件，避免全表扫描。
批量操作：用 INSERT INTO ... VALUES (...), (...) 批量插入，减少连接次数；用 UPDATE 批量更新，避免循环单条操作。
子查询优化：将子查询改为 JOIN（若子查询无相关性），提升效率。
3. **利用查询缓存**
若数据库支持查询缓存（如 MySQL 旧版本），相同查询可直接从缓存获取结果，但需注意缓存失效（表数据更新时缓存会清除）。
4. **分析执行计划**
用 EXPLAIN 分析 SQL 执行计划，查看是否走索引、表扫描方式等，针对性优化。

==Redis 与 MySQL 协同核心是 “热点数据放 Redis 加速读，冷数据存 MySQL 保持久，写操作更 MySQL 后删 Redis 缓存”，再通过以下方式保障==：
**读**：先查 Redis，未命中查 MySQL 并回写 Redis（设过期时间）。
**写**：先更 MySQL，再删 Redis 缓存（避免脏数据）。
**一致性**：用过期时间、延迟双删（高并发更新）、缓存空值（防穿透）等策略。

==思考==
建表时要深思熟虑，少一些繁琐重复不必要的字段，要利用表之间的关联来简洁数据便于查询