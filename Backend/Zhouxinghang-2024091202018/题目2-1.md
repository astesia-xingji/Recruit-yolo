==本质是通过节点间的指针（或引用）建立逻辑关联，形成链式存储结构。每个节点包含数据域和指针域，指针域存储数据，指针域指向后续节点，从而实现数据的线性组织。==
**动态伸缩能力**：数组在初始化时需固定大小，扩容需重新分配连续内存间并复制元素；链表无需预设容量，可通过增减增节点（调整指针）随时扩展或缩减，内存利用率更高。
**插入 / 删除效率**：数组中插入或删除元素需移动后续元素（时间复杂度 O (n)）；链表仅需修改相邻节点的指针（时间复杂度 O (1)，已知前驱节点时），尤其适合频繁变动的场景。
**内存利用灵活性**：数组要求连续的内存空间，可能导致内存碎片或分配失败；链表节点可分散存储在内存各处，只需保证指针指向正确，对内存连续性无要求。
**空间开销权衡**：链表需额外存储指针域（空间开销略大），但避免了数组可能的预留空间浪费；数组则通过连续存储实现随机访问（O (1) 时间复杂度），这是链表（需顺序遍历，O (n)）无法替代的优势。

```java
package com.yolo2;

//实现的是泛型的，类型为T
public class MyLinkedList<T>{
    private class Node{
        T element;
        Node nextNode;

        public Node(T element){
            this.element=element;
            this.nextNode=null;
        }
    }

    private Node firstNode;

    //开始实现有关方法
    //这是创建一个新的链表
    public MyLinkedList(){
        this.firstNode=null;
    }

    //添加一个元素使其成为链表最后一个元素
    public void add(T element){
        if(firstNode==null){
            firstNode=new Node(element);
            return;
        }
        Node newNode=new Node(element);
        Node tempNode=firstNode;
        while(tempNode.nextNode!=null){
            tempNode=tempNode.nextNode;
        }
        tempNode.nextNode=newNode;
    }

    //添加一个元素使其成为链表第index个元素
    public void insert(int index,T element){
        //先检查index是否越界链表，若是则返回报错（允许index比最后一个节点序号大一，表示在最末尾添加一个新的节点）
        if(size()+1<index||index<=0){
            System.out.println("ERROR!");
            return;
        }

        Node newNode=new Node(element);
        if(index==1){
            //这是在链表头部插入
            newNode.nextNode=firstNode;
            firstNode=newNode;
        }else if(index==size()+1){
            //这是在链表尾部加入
            Node tempNode=firstNode;
            while(tempNode.nextNode!=null){
                tempNode=tempNode.nextNode;
            }
            tempNode.nextNode=newNode;
        }else{
            //这是在中部加入
            Node tempNode=firstNode;
            //遍历得到第index-1个节点
            for(int i =0;i<index-2;i++){
                tempNode=tempNode.nextNode;
            }
            newNode.nextNode=tempNode.nextNode;
            tempNode.nextNode=newNode;
        }
    }

    //获取链表的第index个元素
    public T get(int index){
        //先检查index是否越界链表，若是则返回报错
        if(size()<index||index<=0){
            System.out.println("ERROR!");
            return null;
        }

        Node tempNode=firstNode;
        //先遍历得到第index个节点
        for(int i=0;i<index-1;i++){
            tempNode=tempNode.nextNode;
        }

        return tempNode.element;
    }

    //移除链表的第index个元素，无返回
    public void remove(int index){
        //先检查index是否越界链表，若是则返回报错
        if(size()<index||index<=0){
            System.out.println("ERROR!");
            return;
        }

        Node tempNode=firstNode;
        //遍历得到第index-1个节点
        for(int i=0;i<index-2;i++){
            tempNode=tempNode.nextNode;
        }

        //保存第index个节点
        Node iNode=tempNode.nextNode;
        //把第index-1个节点后面接上第index+1个节点
        tempNode.nextNode=iNode.nextNode;

    }

    //返回链表的长度
    public int size(){
        int len=0;
        Node tempNode=firstNode;
        while(tempNode!=null){
            len++;
            tempNode=tempNode.nextNode;
        }
        return len;
    }

    //顺序打印链表中节点元素
    public void print(){
        Node tempNode=firstNode;
        if(tempNode==null){
            System.out.println("The list is null.");
            return;
        }
        while(tempNode!=null){
            System.out.print(tempNode.element+"\t");
            tempNode=tempNode.nextNode;
        }
        System.out.println();
    }

    //反转链表
    public void reverse() {
        //空链表或只有一个节点无需反转
        if(firstNode==null||firstNode.nextNode==null){
            return;
        }

        Node lNode=firstNode;
        Node rNode=lNode.nextNode;
        Node llNode=null;
        Node rrNode=rNode.nextNode;

        while(rrNode!=null){
            //逆转lNode和rNode之间的指向
            lNode.nextNode=llNode;
            rNode.nextNode=lNode;

            //四个节点引用整体后移
            llNode=lNode;
            lNode=rNode;
            rNode=rrNode;
            rrNode=rNode.nextNode;
        }

        //处理最后两个节点
        lNode.nextNode=llNode;
        rNode.nextNode=lNode;

        //更新头节点为原链表的最后一个节点
        firstNode.nextNode=null;
        firstNode=rNode;
    }
}
```

```java
package com.yolo2;

public class TestMyLinkedList {
    public static void main(String[] args) {
        MyLinkedList<Integer> ml=new MyLinkedList<>();

        //简单填入数据
        ml.add(1);
        ml.add(2);
        ml.add(3);
        ml.add(4);
        System.out.print("链表为  ");
        ml.print();

        //得到链表长度
        System.out.println("链表长度为"+ml.size());

        //得到第三个位置的数据值
        System.out.println("第三个位置是"+ml.get(3));

        //在第一个位置插入5
        ml.insert(1,5);
        System.out.print("在第一个位置插入5后为  ");
        ml.print();

        //删除第二个位置的数据
        ml.remove(2);
        System.out.print("删除第二个位置的数据为  ");
        ml.print();

        //逆转链表
        ml.reverse();
        System.out.print("逆转链表为  ");
        ml.print();

    }
}
```

==思考==
反转链表使用了四个连续节点并排向后移动来达到目的，可能还是逻辑不够简洁，且细微逻辑有些杂乱，反复改了好几次才试对