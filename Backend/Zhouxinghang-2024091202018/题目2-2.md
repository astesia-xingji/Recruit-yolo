1. ==思考一下，你能否只用“能量井”（栈）来模拟出“能量通道”（队列）的效果？反之，用“能量通道”能否模拟“能量井”？请阐述你的思路，无需编码。==
**栈模拟队列**：用两个栈ab来组合，a栈从栈底到栈顶即是队列的头到尾，b栈负责中转。
*入队*：将a栈内元素全部弹出到b栈，入队元素压入a栈，然后将b栈元素全弹回到a栈。
*出队*：直接从a栈弹出一个元素。
**队列模拟栈**：用两个队列ab来组合，a队列从队首到队尾即是栈的底部到顶部，b队列负责中转。
*入栈*：将a队列全部出到b队列去，入栈元素进入a队列，然后将b队列元素弹出返回到a队列。
*出栈*：直接从a队列弹出一个元素。

2. ==在Java的官方魔法库中，是否存在现成的“栈”与“队列”实现？若有，它们是如何构建的？与你亲手打造的相比，有何异同与优劣？==
存在。栈基于动态数组，队列基于双向链表或者循环数组或者堆。
**不同点**：官方的更完善效率更高，而我实现的更为简洁。
**相同点**：都是基于“后入先出”（栈）和“先入先出”（队列）的严密逻辑建构。
**优劣**：官方的功能更为丰富，高效，更有安全性，但单线线程下安全特性多余会带来额外的性能开销；自己手动实现的比较简洁，便于理解底层逻辑，但功能不齐全，缺乏线程安全支持。

```java
package com.yolo2;

import java.util.LinkedList;

public class MyStack<T> {
    //做的泛型栈
    private LinkedList<T> linkedList;

    //创建栈
    public MyStack(){
        linkedList=new LinkedList<>();
    }

    //压入栈
    void push(T value) {
        linkedList.add(value);
    }

    //弹出栈
    T pop() {
        if(linkedList.isEmpty()){
            System.out.println("栈为空！");
            return null;
        }else{
            return linkedList.removeLast();
        }
    }

    //取得栈顶元素
    T peek() {
        if(linkedList.isEmpty()){
            System.out.println("栈为空！");
            return null;
        }else{
            return linkedList.getLast();
        }
    }

    //判断栈是否为空
    boolean isEmpty() {
        return linkedList.isEmpty();
    }

    //打印栈
    void print(){
        System.out.println(linkedList.toString());
    }

}
```

```java
package com.yolo2;

import java.util.LinkedList;

public class MyQueue<T> {
    //做了一个泛型队列，首入尾出
    private LinkedList<T> linkedList;

    //创建一个队列
    public MyQueue(){
        linkedList=new LinkedList<>();
    }

    //元素进入队列
    void enqueue(T value){
        if(linkedList.isEmpty()){
            linkedList.add(value);
        }else{
            linkedList.addFirst(value);
        }
    }

    //元素出队列
    T dequeue(){
        if(linkedList.isEmpty()){
            System.out.println("队列中没有元素");
            return null;
        }else{
            return linkedList.removeLast();
        }
    }

    //查看即将出队列的元素
    T peek(){
        if(linkedList.isEmpty()){
            System.out.println("队列中没有元素");
            return null;
        }else{
            return linkedList.getLast();
        }
    }

    //判断队列是否为空
    boolean isEmpty(){
        return linkedList.isEmpty();
    }

    void print(){
        System.out.println("队列为"+linkedList.toString());
    }
}
```

```java
package com.yolo2;

public class TestMyStack {
    public static void main(String[] args) {
        MyStack<Integer> myStack=new MyStack<>();

        //依次压入元素
        myStack.push(1);
        myStack.push(2);
        myStack.push(3);
        myStack.push(4);
        myStack.print();

        //得栈顶元素
        System.out.println("栈顶元素为"+myStack.peek());

        //弹出两个元素并打印
        System.out.println("弹出"+myStack.pop());
        System.out.println("弹出"+ myStack.pop());

        //打印弹出后的栈
        myStack.print();
    }
}

```

```java
package com.yolo2;

public class TestMyQueue {
    public static void main(String[] args) {
        MyQueue<Integer> myQueue=new MyQueue<>();

        //元素依次进入队列
        myQueue.enqueue(4);
        myQueue.enqueue(3);
        myQueue.enqueue(2);
        myQueue.enqueue(1);
        myQueue.print();

        //两个元素出队列
        System.out.println("出队列，该元素为"+myQueue.dequeue());
        System.out.println("出队列，该元素为"+myQueue.dequeue());

        //将3加入队列
        myQueue.enqueue(3);
        System.out.print("将3加入队列, ");
        myQueue.print();

        //展示尾部元素
        System.out.println("现队列尾部元素为"+myQueue.peek());

    }
}
```
==思考==
栈和队列其实都是一种基于逻辑思维的抽象转为结构体的例子，且进出元素的方式有对称性，故在思维上一定能够互相推出