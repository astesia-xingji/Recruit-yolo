1. ==了解并阐述成员内部类、静态内部类、局部内部类和匿名内部类的定义、特点及适用场景。==
**成员内部类（Member Inner Class）**
**定义**：直接定义在外部类的成员位置（与成员变量、成员方法同级），未使用static修饰的内部类。
**特点**：依赖外部类实例存在，需先创建外部类对象才能创建内部类对象。可直接访问外部类的所有成员（包括私有成员）。外部类访问内部类成员需通过内部类实例。内部类中不能定义静态成员（静态常量除外）。
**适用场景**：当内部类与外部类联系紧密，需要频繁访问外部类成员时使用。
**静态内部类（Static Inner Class）**
**定义**：使用static修饰的成员内部类，也称为嵌套类（Nested Class）。
**特点**：不依赖外部类实例，可直接通过外部类.内部类方式创建对象。只能访问外部类的静态成员（非静态成员需通过外部类实例访问）。内部类中可以定义静态成员和非静态成员。与外部类的实例无关，属于外部类本身。
**适用场景**：当内部类与外部类逻辑相关，但无需依赖外部类实例时使用。常用于工具类或为外部类提供辅助功能的类。
**局部内部类（Local Inner Class）**
**定义**：定义在方法、代码块等局部作用域内的内部类。
**特点**：作用域仅限于所在的方法或代码块，外部无法直接访问。可访问外部类的所有成员，以及所在方法中的final或有效 final（隐式 final）局部变量。不能使用访问修饰符（public、private 等）和static修饰。
**适用场景**：仅在当前方法内部需要复用某个类，且逻辑简单时使用。
**匿名内部类（Anonymous Inner Class）**
**定义**：没有类名的局部内部类，通常用于快速创建一个接口或抽象类的实现对象。
**特点**：必须继承一个父类或实现一个接口，且只能继承一个类或实现一个接口。定义时立即创建实例，不能单独存在或重复使用。作用域与局部内部类相同，可访问外部类成员和final局部变量。语法简洁，省去了显式定义类的步骤。
**适用场景**：当需要临时创建一个接口 / 抽象类的实现，且仅使用一次时。常见于事件监听（如ActionListener）、线程创建（Runnable）等场景。


2. ==这种链式调用的构造方式，相比传统的构造方法，有何优点？（提示：参数过多、可选参数、不可变对象）==
**解决参数过多问题，提升代码可读性**
传统构造方法在参数较多时，容易出现 "参数列表过长" 的问题，调用时难以区分参数的含义和顺序，可读性差。链式调用通过分步设置参数，每个方法只处理一个或少数相关参数，并通过方法名明确参数含义，代码更易理解
**灵活处理可选参数，避免 "telescoping constructor"（重叠构造器）问题**
当类存在多个可选参数时，传统方式需定义多个重载构造器（参数数量递减），导致代码冗余且维护成本高。链式调用允许按需设置可选参数，无需为不同组合定义重载方法，减少代码冗余
**便于创建不可变对象（Immutable Object）**
不可变对象（所有字段为final，创建后不可修改）具有线程安全、减少副作用等优点，但传统构造方法需在创建时一次性传入所有参数，灵活性低。链式调用通过建造者暂存参数，最后一次性创建不可变对象，兼顾灵活性和不可变性

3. ==在Java 8之后，Lambda表达式让匿名内部类的使用变得更简洁。请了解常见的“函数式接口”（如Comparator, Runnable）。==
函数式接口（Functional Interface） 是只包含一个抽象方法的接口（可以包含多个默认方法或静态方法）。正因为只有一个抽象方法，Lambda 表达式才能无缝替代其匿名内部类的实现，从而大幅简化代码。
**Runnable（java.lang.Runnable）**
抽象方法：void run()（无参数、无返回值）
用途：定义线程执行的任务
**Comparator<T>（java.util.Comparator）**
抽象方法：int compare(T o1, T o2)（接收两个同类型参数，返回 int 表示比较结果）
用途：定义对象的比较规则（如排序）

4. ==你的宠物店需要一个全局唯一的“交互管理器”（InteractionManager）来处理所有宠物之间的互动。“单例模式”确保了这种唯一性。请了解其概念和至少两种实现方式（如懒汉式、饿汉式）。==
**单例模式**确保一个类仅有一个实例，并提供全局访问点，适合 "交互管理器" 这种需要唯一协调者的场景。
**饿汉式**：优点：简单、线程安全；缺点：类加载即初始化，可能浪费资源。
**懒汉式**：优点：按需初始化，节省资源；缺点：实现稍复杂，需处理线程安全。

5. ==策略模式是一种行为型设计模式，它将算法（或行为）封装为独立的策略类，使得它们可以相互替换，从而让算法的变化独立于使用算法的客户端。==
**核心思想**
*分离变化与不变*：将易变的行为（策略）从主类中抽离，形成独立的策略接口和实现类。
*动态切换*：客户端可以在运行时根据需求切换不同的策略，无需修改原有代码。
**关键角色**
*策略接口（Strategy）*：定义所有策略的统一方法（如 interact()）。
*具体策略（ConcreteStrategy）*：实现策略接口，封装具体的算法（如 PlayStrategy、FightStrategy）。
*上下文（Context）*：使用策略的类（如 InteractionManager），持有策略接口的引用，负责调用策略。