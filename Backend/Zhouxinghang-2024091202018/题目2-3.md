==请简要说明“二叉树”这种数据结构的核心特点。==
- 二叉树由**节点**组成，每个节点包含一个数据元素，以及两个指向子节点的引用（或指针），分别称为左子节点和右子节点。二叉树的左子节点和右子节点分别构成该节点的左子树和右子树，而左、右子树本身也是二叉树。
- 叶子节点：没有子节点的节点（左右子节点均为 null）。
- 分类：
  **满二叉树**：除叶子节点外，每个节点都有左、右两个子节点，且所有叶子节点在同一层级。
  **完全二叉树**：叶子节点集中在最后两层，且最后一层的节点都靠左排列。
  **二叉搜索树**（BST）：左子树所有节点值 < 根节点值 < 右子树所有节点值。

```java
package com.yolo2;

// 树节点的定义
class TreeNode {
    int val; // 节点蕴含的能量值
    TreeNode left, right; // 指向左右两个思维分支的引用
    TreeNode(int val) { this.val = val; }
}

public class BinaryTreeTraversal {

    // 构建一个样本智慧核心（由遍历结果知结构如下）
//        1
//       / \
//      2   3
//     / \   \
//    4   5   6
    public static TreeNode buildSampleTree() {
        TreeNode treeNode1=new TreeNode(1);
        TreeNode treeNode2=new TreeNode(2);
        TreeNode treeNode3=new TreeNode(3);
        TreeNode treeNode4=new TreeNode(4);
        TreeNode treeNode5=new TreeNode(5);
        TreeNode treeNode6=new TreeNode(6);

        treeNode1.left=treeNode2;
        treeNode1.right=treeNode3;
        treeNode2.left=treeNode4;
        treeNode2.right=treeNode5;
        treeNode3.right=treeNode6;

        return treeNode1;
    }

    // 前序遍历（核心 -> 左分支 -> 右分支）
    public static void preorder(TreeNode node) {
        if(node==null){
            return;
        }
        System.out.print(node.val+" ");
        preorder(node.left);
        preorder(node.right);
    }
    // 中序遍历（左分支 -> 核心 -> 右分支）
    public static void inorder(TreeNode node) {
        if(node==null){
            return;
        }
        inorder(node.left);
        System.out.print(node.val+" ");
        inorder(node.right);
    }
    // 后序遍历（左分支 -> 右分支 -> 核心）
    public static void postorder(TreeNode node) {
        if(node==null){
            return;
        }
        postorder(node.left);
        postorder(node.right);
        System.out.print(node.val+" ");
    }

    // 测试
    public static void main(String[] args) {
        TreeNode root = buildSampleTree();
        System.out.print("前序探知：");
        preorder(root); // 预期输出: 1 2 4 5 3 6
        System.out.println();

        System.out.print("中序探知：");
        inorder(root); // 预期输出: 4 2 5 1 3 6
        System.out.println();

        System.out.print("后序探知：");
        postorder(root); // 预期输出: 4 5 2 6 3 1
    }
}
```
==思考==
树的遍历这一思维和c语言课上基本一模一样，简单但是需要遍历的重要思想，直接从c语言照搬即可得出